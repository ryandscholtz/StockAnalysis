name: Deployment Pipeline

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      aws-region:
        required: false
        type: string
        default: 'us-east-1'
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    
    outputs:
      deployment-approved: ${{ steps.approval.outputs.approved }}
      
    steps:
    - uses: actions/checkout@v4
    
    - name: Validate environment
      run: |
        if [[ "${{ inputs.environment }}" != "staging" && "${{ inputs.environment }}" != "production" ]]; then
          echo "Invalid environment: ${{ inputs.environment }}"
          exit 1
        fi
        
    - name: Check deployment window
      run: |
        # Allow production deployments at any time for personal projects
        # Business hours restriction can be enabled for enterprise environments
        echo "Deployment allowed - personal project deployment"
        
        # Uncomment below for enterprise business hours restriction:
        # if [[ "${{ inputs.environment }}" == "production" ]]; then
        #   current_hour=$(date -u +%H)
        #   current_day=$(date -u +%u)  # 1=Monday, 7=Sunday
        #   
        #   # Allow deployments Monday-Friday, 9 AM - 5 PM UTC
        #   if [[ $current_day -gt 5 || $current_hour -lt 9 || $current_hour -gt 17 ]]; then
        #     echo "Production deployments are only allowed during business hours (Mon-Fri, 9 AM - 5 PM UTC)"
        #     exit 1
        #   fi
        # fi
        
    - name: Manual approval for production
      id: approval
      if: inputs.environment == 'production'
      run: |
        echo "⚠️ Production deployment proceeding automatically"
        echo "This is a personal project - manual approval disabled"
        echo "For enterprise environments, enable manual approval with proper GitHub permissions"
        echo "approved=true" >> $GITHUB_OUTPUT

  backup-current-state:
    name: Backup Current State
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: inputs.environment == 'production'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ inputs.aws-region }}
        
    - name: Create database backup
      run: |
        echo "Creating database backup..."
        # Add DynamoDB backup commands here
        aws dynamodb create-backup \
          --table-name stock-analyses-production \
          --backup-name "pre-deployment-$(date +%Y%m%d-%H%M%S)"
          
    - name: Backup configuration
      run: |
        echo "Backing up current configuration..."
        # Add configuration backup logic here

  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, backup-current-state]
    if: always() && (needs.pre-deployment-checks.result == 'success') && (inputs.environment != 'production' || needs.backup-current-state.result == 'success')
    environment: ${{ inputs.environment }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ inputs.aws-region }}
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: infrastructure/package-lock.json
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Package Lambda function
      working-directory: ./backend
      run: |
        # Create dist directory
        mkdir -p dist
        
        # Copy application code
        cp -r app dist/
        cp lambda_handler.py dist/
        
        # Create requirements file with essential dependencies only
        cat > requirements-lambda.txt << 'EOF'
        fastapi==0.104.1
        pydantic==2.5.0
        mangum==0.17.0
        boto3==1.34.0
        python-dotenv==1.0.0
        requests>=2.32.2
        yfinance==0.2.28
        pandas==2.1.3
        numpy==1.26.2
        sqlalchemy==2.0.23
        httpx==0.25.2
        beautifulsoup4==4.12.2
        python-multipart==0.0.6
        PyJWT==2.8.0
        passlib==1.7.4
        EOF
        
        # Install dependencies with compatible versions
        pip install -r requirements-lambda.txt -t dist/ --no-deps
        
        # Install core dependencies that are needed
        pip install starlette==0.27.0 typing-extensions annotated-types pydantic-core==2.14.1 -t dist/
        pip install botocore jmespath s3transfer urllib3 certifi charset-normalizer idna -t dist/
        pip install python-dateutil six pytz tzdata -t dist/
        pip install anyio==3.7.1 sniffio exceptiongroup -t dist/
        
        # Clean up unnecessary files to reduce size
        find dist/ -name "*.pyc" -delete
        find dist/ -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
        find dist/ -name "*.dist-info" -type d -exec rm -rf {} + 2>/dev/null || true
        find dist/ -name "tests" -type d -exec rm -rf {} + 2>/dev/null || true
        
        echo "Lambda package created successfully"
        du -sh dist/
        ls -la dist/
        
    - name: Install CDK dependencies
      working-directory: ./infrastructure
      run: npm ci
      
    - name: Build CDK
      working-directory: ./infrastructure
      run: npm run build
      
    - name: CDK Bootstrap (if needed)
      working-directory: ./infrastructure
      run: |
        npx cdk bootstrap --context environment=${{ inputs.environment }}
        
    - name: CDK Diff
      working-directory: ./infrastructure
      run: |
        npx cdk diff --context environment=${{ inputs.environment }} > cdk-diff.txt
        cat cdk-diff.txt
        
    - name: Deploy infrastructure
      working-directory: ./infrastructure
      run: |
        npx cdk deploy --all \
          --context environment=${{ inputs.environment }} \
          --require-approval never \
          --outputs-file outputs.json
          
    - name: Upload deployment outputs
      uses: actions/upload-artifact@v4
      with:
        name: deployment-outputs-${{ inputs.environment }}
        path: infrastructure/outputs.json
        
    - name: Deploy application code
      run: |
        echo "Deploying application code to ${{ inputs.environment }}..."
        # Add application deployment logic here
        
  post-deployment-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: deploy
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download deployment outputs
      uses: actions/download-artifact@v4
      with:
        name: deployment-outputs-${{ inputs.environment }}
        path: ./
        
    - name: Extract API endpoint
      id: endpoints
      run: |
        API_ENDPOINT=$(jq -r '.["StockAnalysisInfrastructure-${{ inputs.environment }}"].ApiUrl' outputs.json)
        echo "api-endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT
        echo "Extracted API endpoint: $API_ENDPOINT"
        
    - name: Health check
      run: |
        echo "Running health check against ${{ steps.endpoints.outputs.api-endpoint }}"
        curl -f "${{ steps.endpoints.outputs.api-endpoint }}health" || exit 1
        
    - name: Smoke tests
      run: |
        echo "Running smoke tests..."
        # Test health endpoint
        curl -f "${{ steps.endpoints.outputs.api-endpoint }}health"
        
        # Test FastAPI docs endpoint
        curl -f "${{ steps.endpoints.outputs.api-endpoint }}docs"
        
        # Test OpenAPI spec endpoint
        curl -f "${{ steps.endpoints.outputs.api-endpoint }}openapi.json"
        
        # Test API search endpoint (should work with full FastAPI)
        curl -f "${{ steps.endpoints.outputs.api-endpoint }}api/search?q=AAPL" || echo "Search endpoint not ready yet"
        
        echo "Smoke tests completed successfully"
        
    - name: Performance validation
      run: |
        echo "Validating performance..."
        # Add performance validation logic here
        
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy, post-deployment-tests]
    if: failure() && inputs.environment == 'production'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ inputs.aws-region }}
        
    - name: Rollback infrastructure
      working-directory: ./infrastructure
      run: |
        echo "Rolling back infrastructure changes..."
        # Add rollback logic here
        
    - name: Restore database backup
      run: |
        echo "Restoring database from backup..."
        # Add database restore logic here

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [deploy, post-deployment-tests]
    if: success()
    
    steps:
    - name: Log deployment success
      run: |
        echo "✅ Deployment to ${{ inputs.environment }} successful!"
        echo "Environment: ${{ inputs.environment }}"
        echo "Branch: ${{ github.ref }}"
        echo "Commit: ${{ github.sha }}"
        echo "GitHub will send email notifications for deployment status"